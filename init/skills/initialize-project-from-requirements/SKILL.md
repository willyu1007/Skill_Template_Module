# Skill: initialize-project-from-requirements

This skill connects the flow from **requirements docs → project blueprint → scaffold/configs → skill sync**, and records an auditable initialization state so every stage has a clear **validation + user approval** checkpoint.

Goal: a robust, repeatable, rollback-friendly initialization workflow (not the fastest possible iteration).

---

## Inputs

### Stage A (requirements docs, required)

Located under `docs/project/` (or the `--docs-root` you provide):

- `docs/project/requirements.md`
- `docs/project/non-functional-requirements.md`
- `docs/project/domain-glossary.md`
- `docs/project/risk-open-questions.md`

### Stage B (blueprint, required)

- `docs/project/project-blueprint.json`

### Core capability: Context system (built-in)

In the module-first template, the Context system is a **built-in capability** (it is no longer installed from `addons/context-awareness`).

Default behavior:
- `contextAwareness` is the enable/disable switch for this core capability. Unless the blueprint explicitly disables `addons.contextAwareness: false`, the built-in steps run:
  - `node .ai/scripts/projectctl.js init`
  - `node .ai/scripts/projectctl.js set-context-mode <contract|snapshot>`
  - `node .ai/scripts/contextctl.js init`
  - `node .ai/scripts/contextctl.js build`
- Optional: if `init-pipeline.cjs apply` is run with `--verify-addons`, it also runs `node .ai/scripts/contextctl.js verify`

---

## Outputs (written artifacts)

### Stage A

- Requirements docs (`docs/project/*`)
- Init state file: `init/.init-state.json`

### Stage B

- Blueprint: `docs/project/project-blueprint.json`

### Stage C

- Scaffolded directory structure (examples):
  - `src/` or `apps/` + `packages/` (based on `repo.layout`)
  - `docs/diagrams/` (if diagram capability is enabled)
  - `ops/` (if DevOps scaffold is enabled; see below)
- Config files (generated by `scripts/scaffold-configs.cjs`): e.g. `.gitignore`, lint/test/format configs (based on the blueprint)
- Skills selection (SSOT):
  - `.ai/skills/_meta/sync-manifest.json` (flat schema: `version/includePrefixes/includeSkills/excludeSkills`)
  - Add-on mode: if `.ai/scripts/skillsctl.js` exists, pack toggles MUST be applied via skillsctl (scheme A)
- Provider wrapper generation/update:
  - `node .ai/scripts/sync-skills.cjs` (supports `--providers`)

### Context system outputs (built-in)

When `contextAwareness` is not explicitly disabled (enabled by default) and `apply` is executed, the following core artifacts are ensured/generated:

- `.ai/scripts/contextctl.js`
- `.ai/scripts/projectctl.js`
- `docs/context/` (context registries, workflows, etc.; maintained by built-in scripts)

Note: the Context system is not installed from `addons/`. Even if `addons.contextAwareness: false` is set, these files remain part of the template core; the init/build/verify steps are just skipped.

---

## Critical process rules (MUST)

1. Every stage transition MUST have “validation + user approval”.
   - Validation is recorded by script commands in `init/.init-state.json`.
   - Advancing stages MUST be done via the explicit `approve` command (do not hand-edit the state file to skip stages).
2. Do not advance stages without explicit user approval.
3. Context system (core capability) enable switch:
   - `addons.contextAwareness` is the built-in enable switch; default is enabled unless explicitly `false`.
   - It does not install anything from `/addons/<addonId>/payload` (Context is not an add-on).
   - `blueprint.context.*` is configuration-only; it does not trigger installation.
4. The manifest schema MUST be the “flat schema”.
   - Do not use `collections.current` or similar nested structures.
5. Single source of truth for config generation: `scripts/scaffold-configs.cjs`.

---

## Standard workflow

For detailed stage-by-stage commands, see:
- `init/stages/01-stage-a-requirements.md`
- `init/stages/02-stage-b-blueprint.md`
- `init/stages/03-stage-c-scaffold-and-skills.md`

Or use `init/README.md` for a quick start guide.

---

## Context system

See `init/addon-docs/context-awareness.md` for details on the built-in context registry system.

---

## `/addons` directory conventions (optional)

`addons/` is only for optional **non-core** capabilities (e.g. packaging/deployment/release/observability).

See:
- `init/addon-docs/convention.md`

---

## DevOps scaffold (see `init/stages/03-stage-c-scaffold-and-skills.md`)

If any of the following is true, Stage C scaffolding creates an `ops/` directory skeleton:
- `blueprint.quality.ci.enabled: true`
- `blueprint.quality.devops.*` is enabled
- `blueprint.devops.enabled: true` (or its child flags)

Typical structure:
- `ops/packaging/{services,jobs,apps,scripts,workdocs}/`
- `ops/deploy/{http_services,workloads,clients,scripts,workdocs}/`

These are intentionally placeholders (not bound to a specific cloud vendor/CI platform) so they can be extended safely later.

---

## LLM-guided initialization flow

This skill supports an LLM (AI assistant) guiding a user through the entire initialization workflow, without requiring the user to manually edit config files.

### Guidance docs

- **`templates/llm-init-guide.md`** - complete LLM guide
- **`templates/conversation-prompts.md`** - conversation question bank and branch modules

### Flow overview

```
Phase 1: Requirements interview → Phase 2: Tech stack selection → Phase 3: Blueprint generation
    → Phase 4: Add-on recommendations → Phase 5: Config generation → apply command
```

### Phase 1–4: conversation-driven guidance

The LLM should follow the question order in `conversation-prompts.md`:

1. **Module A**: must-ask questions (requirements, users, constraints)
2. **Module B**: branch modules (API, database, BPMN, CI)
3. **Module D**: add-on decisions
4. **Module E**: tech stack selection (language, frameworks, package manager)

### Phase 5: config generation

#### Languages with built-in templates

For these languages, `apply` generates config automatically:

| Language | Template directory |
|----------|--------------------|
| TypeScript/JavaScript | `scaffold-configs/typescript-pnpm/` |
| Go | `scaffold-configs/go/` |
| C/C++ | `scaffold-configs/cpp-xmake/` |
| React Native | `scaffold-configs/react-native-typescript/` |

#### Languages without templates (LLM-generated)

For these languages, the LLM generates config based on `llm-init-guide.md`:

- Python → `pyproject.toml`, directory structure
- Java → `build.gradle.kts` or `pom.xml`
- Kotlin → `build.gradle.kts`
- .NET → `*.csproj`, `global.json`
- Rust → `Cargo.toml`
- Other languages → generate based on language conventions

**LLM generation flow**:

1. The `apply` command detects a missing template and prints guidance
2. The LLM uses the language/framework info from the blueprint
3. Reference `llm-init-guide.md` Phase 5
4. Generate the required config files and directory structure
5. Continue only after user confirmation

### Example conversation

```
AI: Let's start initializing your project. First, in one sentence, describe what the project does.

User: An inventory management system for small businesses.

AI: Got it. Who are the primary users? What must-have capabilities are required?

User: Warehouse managers. Must-have: inbound, outbound, inventory lookup, low-stock alerts.

AI: Understood. For the tech stack, what is the preferred programming language?

User: Python

AI: Python doesn't have a built-in template here, so I'll generate the config files...
[LLM generates pyproject.toml, etc. based on llm-init-guide.md]

AI: Config files are generated. Now run the apply command:
node init/.../init-pipeline.cjs apply --blueprint docs/project/project-blueprint.json
```

---

## References

- `templates/llm-init-guide.md` - complete LLM guide
- `templates/conversation-prompts.md` - conversation question bank
- `templates/project-blueprint.schema.json` - Blueprint JSON Schema
- `templates/project-blueprint.example.json` - full example
- `templates/project-blueprint.min.example.json` - minimal example
- `reference.md` - technical reference
